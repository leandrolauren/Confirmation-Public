from fastapi import HTTPException
from models import ConfirmationCreate, Connection
import logging

logger = logging.getLogger(__name__)


# Function to create the table
def create_table():
    try:

        with Connection() as conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS public.confirmations
                (
                    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
                    name text COLLATE pg_catalog."default" NOT NULL DEFAULT ''::text,
                    email text COLLATE pg_catalog."default" NOT NULL DEFAULT ''::text,
                    phone text COLLATE pg_catalog."default" DEFAULT 'NULL'::text,
                    confirmation boolean NOT NULL DEFAULT true,
                    confirmation_date date NOT NULL DEFAULT CURRENT_DATE,
                    qtt_adult smallint NOT NULL DEFAULT '1'::smallint,
                    qtt_child smallint,
                    CONSTRAINT confirmations_pkey PRIMARY KEY (id),
                    CONSTRAINT confirmations_email_key UNIQUE (email),
                    CONSTRAINT confirmations_qtt_adult_check CHECK (qtt_adult > 0),
                    CONSTRAINT confirmations_qtt_child_check CHECK (qtt_child >= 0)
                )
                """
            )

        return {f"success": True, "message": "Table created successfully"}

    except Exception as e:
        logger.error(f"Error creating table: {e}")
        raise


# Function to insert a new confirmation
def insert_confirmation(
    name,
    email,
    phone,
    confirmation,
    qtt_adult,
    qtt_child,
) -> dict:
    try:
        with Connection() as conn:
            conn.execute(
                "INSERT INTO public.confirmations (name, email, phone, confirmation, qtt_adult, qtt_child) VALUES (%s, %s, %s, %s, %s, %s)",
                (
                    name,
                    email,
                    phone,
                    confirmation,
                    qtt_adult,
                    qtt_child,
                ),
            )

        return {
            f"success": True,
            "message": "Confirmation inserted successfully",
        }

    except Exception as e:
        logger.error(f"Error inserting confirmation: {e}")
        raise HTTPException(
            status_code=400,
            detail=f"Error inserting confirmation: {e}",
        )


# Function to read all confirmations
def read_confirmation() -> dict:
    try:
        with Connection() as conn:
            confirmations = conn.execute(
                "SELECT name, email, phone, confirmation, qtt_adult, qtt_child FROM public.confirmations",
                None,
            )

        result = []
        for row in confirmations:
            result.append(
                {
                    "name": row[0],
                    "email": row[1],
                    "phone": row[2],
                    "confirmation": row[3],
                    "qtt_adult": row[4],
                    "qtt_child": row[5],
                }
            )

        return {
            f"success": True,
            "message": "Confirmations read successfully",
            "data": result,
        }

    except Exception as e:
        logger.error(f"Error reading confirmations: {e}")
        return {
            f"success": False,
            "message": f"Error reading confirmations: {e}",
            "data": [],
        }


# This function will be used to check if the email is already in the database before inserting a new confirmation
def validate_email(email):

    with Connection() as conn:
        existing = conn.execute(
            "SELECT email FROM confirmations WHERE email = %s", (email,)
        )

    return existing
